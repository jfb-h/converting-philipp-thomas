{
  "hash": "46cfb0ac5415e66ef146d374d5420f91",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Programming Basics\"\neditor: visual\n---\n\n\n\n# Scripting workflows\n\nIn `R`, instead of clicking buttons in a Graphical User Interface (GUI) in a specific sequence, you write the steps of your analysis as commands into a script. The steps can then be performed by running the script in `R` , or by manually running specific steps.\n\n**Advantages**: The script can be executed repeatedly, once written. This means that you or someone else can *reproduce* your analysis more easily at a later point. It also means that if you want to change something, you just need to change the specific part of the script after which you can rerun the whole analysis with the changes.\n\n**Disadvantages**: You need to learn the rules of how to construct commands (*syntax*) and pay attention to spelling because programming languages are very strict and will error when commands are misspelled or its syntax rules are violated. For finding the commands to run specific analyses (*discoverability)*, instead of clicking through the program, you need to refer to documentation (external or built-in).\n\nWhile there is a steep learning curve initially, the benefits of reproducible science and the possibilities for more complex analyses mean that the advantages tend to outweigh the disadvantages.\n\n::: callout-note\n## Quarto notebooks\n\nAny applied project is an iterative process which involves a back-and-forth between writing code, looking at data and plots, and taking notes. This document is a *Quarto notebook,* which allows you to **combine prose with code and code output**, such as tables or plots, in one place.\n\nWe can compile this notebook to various output formats with the big blue *Render* button to produce **nice-looking and reproducible reports**.\n\nQuarto allows us to combine different programming languages in one environment. We can include a *code chunk* containing executable code by writing `/` in an empty line of the notebook.\n:::\n\n## Example: A network analysis in four lines of code\n\nIn the following example, we show a minimal example of the typical workflow of most statistical analyses, which includes data import, data preparation, computation of summaries, and preparation of results:\n\n**Step 0**: Load packages (`R` is extensible and has a huge ecosystem of functionality)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sna)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: statnet.common\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'statnet.common'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    attr, order\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: network\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n'network' 1.19.0 (2024-12-08), part of the Statnet Project\n* 'news(package=\"network\")' for changes since last version\n* 'citation(\"network\")' for citation information\n* 'https://statnet.org' for help, support, and other information\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nsna: Tools for Social Network Analysis\nVersion 2.7-2 created on 2023-12-05.\ncopyright (c) 2005, Carter T. Butts, University of California-Irvine\n For citation information, type citation(\"sna\").\n Type help(package=\"sna\") to get started.\n```\n\n\n:::\n:::\n\n\n\n**Step 1**: Get data from a `.csv` file:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedgelist <- read.csv(\"data/edgelist.csv\", header=TRUE)\n```\n:::\n\n\n\n**Step 2**: Create a network object:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnet <- network(edgelist, directed=FALSE)\n```\n:::\n\n\n\n**Step 3**: Compute a network summary (the degree of each actor):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeg <- degree(net)\n```\n:::\n\n\n\n**Step 4**: Plot the network:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngplot(net, gmode=\"graph\",label=1:10, label.pos=5, \n      vertex.col=\"grey\", vertex.cex=sqrt(deg))\n```\n\n::: {.cell-output-display}\n![](01-basics_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n# Variables and functions\n\nThe most basic components of almost all programming languages are *variables* and *functions*. Variables store values, such as your input data, and have a name with which you can reference the underlying value in your program. Functions usually (but not always) receive some input, based on which they compute some output (or modify the underlying state of the program).\n\n## Variables\n\nTo assign a value to a name, in `R` you use the assignment operator `<-`, which is a 'less than' symbol followed by a minus:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 10 # this is a comment\n```\n:::\n\n\n\nWe can now reference the value using the variable:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\n\nYou can assign arbitrary values to variables, not just numbers:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nname <- \"Jakob\"\n```\n:::\n\n\n\nHere, I assigned the string `\"Jakob\"` to the variable `name`. Strings are how `R` represents text and are constructed with quotation marks (`\"...\"`).\n\nVariable names are case sensitive but cannot include spaces or special symbols, except for underscores (`_`) and period marks (`.`):\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nthis is an invalid name <- 1\nthis-too <- 3\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:2:6: unexpected symbol\n1: \n2: this is\n        ^\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbut_THIS_isnt <- 5\n```\n:::\n\n\n\nIt is recommended to use consistent style for variable names, such as 'snake case', which means chaining different lowercase words with underscores.\n\n## Functions\n\nTo perform any kind of operation, you use a *function*. E.g., to round a decimal number, we use the `round` function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(3.14159)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n\nFunctions can take inputs, called the `arguments`, which go into the parentheses right after the function name. Functions might also return some output, but they don't have to. Most things you do in `R` will involve calling a function on some arguments and assigning the result to a variable name:\n\n![](images/function-call.png)\n\nIn `R`, arguments can be specified by name *or* by position, and often have default values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(3.14159, digits=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14\n```\n\n\n:::\n:::\n\n\n\n## Digression: writing your own functions\n\nYou can define your own functions, which can themselves call other functions:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet <- function(name) {\n  paste(\"Hello\", name)\n}\n```\n:::\n\n\n\nHere, we defined a function called `greet`, which has an argument called `name` that takes in a string and returns a string with a greeting to the passed name. Let's call it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngreet(name=\"Daniel\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello Daniel\"\n```\n\n\n:::\n:::\n\n\n\nNote that the `name` argument only exists as a referenceable variable within the scope of the function.\n\nWe can of course also call the function on a variable 'storing' a name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- \"Daniel\"\ngreet(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello Daniel\"\n```\n\n\n:::\n:::\n\n\n\nWhile you can get very far with only calling functions that are available in base `R` or in packages, it can be very useful to *abstract* certain steps by wrapping them into a function. Imaging, e.g., the following script:\n\n\n\n::: {.cell}\n\n```{.data .cell-code}\n\ndata_cleaned <- clean_and_preprocess_data(data)  \n\nsummaries <- compute_summaries_from_data(data_cleaned) \n\nplot <- plot_data_summaries(summaries)\n```\n:::\n\n\n\nHere, `read_data_from_file` etc. represent functions that conduct certain steps while hiding the details, which can be helpful for organizing complex analytical pipelines.\n\n## Exercises\n\n::: {.callout-note style=\"color: navyblue;\"}\n### Getting Help: ChatGPT & Co.\n\nProgramming frequently involves solving new problems for which you don't know the solution yet. Luckily, most problems have been solved before by other people. Accordingly, many solutions to frequent problems can be found in a variety of places online.\n\nLarge Language Models (LLMs), such as ChatGPT, can be helpful in synthesizing these solutions. But be aware, \"AI\" tools are not all-knowing and will make mistakes or propose non-optimal solutions, just as the people they learned it from did.\n\nWith this in mind, the exercises we do here will frequently go beyond the contents we discussed before. This reflects the process of any real-world project and so will prepare you for pursuing your own research with `R`.\n:::\n",
    "supporting": [
      "01-basics_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}